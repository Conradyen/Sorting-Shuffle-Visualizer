{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/yen/Documents/project/sorting-algo/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\nvar _jsxFileName = \"/Users/yen/Documents/project/sorting-algo/src/components/SortingBoard.tsx\";\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n  width: 100vw;\\n  height: 100vh;\\n  background: var(--background);\\n  align-items: flex-end;\\n  display: flex;\\n\"]);\n\n  _templateObject = function () {\n    return data;\n  };\n\n  return data;\n}\n\nimport React, { useEffect } from \"react\";\nimport { connect } from \"react-redux\";\nimport SortingBar from \"./SortingBar\";\nimport { updateArray } from \"../actions\";\nimport styled from \"styled-components\";\nconst Container = styled.div(_templateObject());\n\nconst SortingBoard = ({\n  sortTarget,\n  updateArray,\n  nextAction,\n  speed\n}) => {\n  // const classes = useStyles();\n  useEffect(() => {\n    //main animation loop\n    if (nextAction !== null && nextAction !== undefined) {\n      let newArray = [...sortTarget]; // let performedAction = action.payload;\n\n      if (nextAction.type === \"comparison\") {\n        newArray[nextAction.first].isCompared = true;\n        newArray[nextAction.second].isCompared = true;\n        updateArray(newArray);\n      } else if (nextAction.type === \"swapColors\") {\n        newArray[nextAction.first].isCompared = false;\n        newArray[nextAction.second].isCompared = false;\n        newArray[nextAction.first].isSwapped = true;\n        newArray[nextAction.second].isSwapped = true;\n      } else if (nextAction.type === \"swap\") {\n        let temp = newArray[nextAction.first];\n        newArray[nextAction.first] = newArray[nextAction.second];\n        newArray[nextAction.second] = temp;\n      } else if (nextAction.type === \"clean\") {\n        newArray.forEach(b => {\n          b.isCompared = false;\n          b.isSwapped = false;\n          b.isPivot = false;\n        });\n      } else if (nextAction.type === \"set_pivot\") {\n        newArray[nextAction.pivot].isPivot = true;\n      }\n\n      updateArray(newArray);\n    }\n  }, [nextAction, updateArray]);\n  return React.createElement(Container, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 67\n    },\n    __self: this\n  }, sortTarget.map((element, i) => React.createElement(SortingBar, {\n    element: element,\n    speed: speed,\n    key: i,\n    index: i,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 69\n    },\n    __self: this\n  })));\n};\n\nconst mapStateToProps = state => ({\n  sortTarget: state.sortTarget,\n  nextAction: state.nextactions,\n  speed: state.speed\n});\n\nconst mapDispatchToProps = dispatch => ({\n  //update array elements\n  updateArray: sortTarget => dispatch(updateArray({\n    sortTarget\n  }))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(SortingBoard);","map":{"version":3,"sources":["/Users/yen/Documents/project/sorting-algo/src/components/SortingBoard.tsx"],"names":["React","useEffect","connect","SortingBar","updateArray","styled","Container","div","SortingBoard","sortTarget","nextAction","speed","undefined","newArray","type","first","isCompared","second","isSwapped","temp","forEach","b","isPivot","pivot","map","element","i","mapStateToProps","state","nextactions","mapDispatchToProps","dispatch"],"mappings":"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","sourcesContent":["import React, { useEffect } from \"react\";\nimport { connect } from \"react-redux\";\nimport SortingBar from \"./SortingBar\";\nimport { updateArray } from \"../actions\";\nimport styled from \"styled-components\";\nimport { ISwapAction, ISortTargetPayload } from \"../constants/Itypes\";\n\ninterface IComponentProps {\n  sortTarget: Array<ISortTargetPayload>;\n  updateArray: (sortTarget: Array<ISortTargetPayload>) => void;\n  nextAction: ISwapAction | null;\n  speed: number;\n}\n\ninterface IComponentState {\n  sortTarget: Array<ISortTargetPayload>;\n  nextactions: ISwapAction | null;\n  speed: number;\n}\n\nconst Container = styled.div`\n  width: 100vw;\n  height: 100vh;\n  background: var(--background);\n  align-items: flex-end;\n  display: flex;\n`;\n\nconst SortingBoard: React.FC<IComponentProps> = ({\n  sortTarget,\n  updateArray,\n  nextAction,\n  speed,\n}) => {\n  // const classes = useStyles();\n  useEffect(() => {\n    //main animation loop\n    if (nextAction !== null && nextAction !== undefined) {\n      let newArray = [...sortTarget];\n      // let performedAction = action.payload;\n      if (nextAction.type === \"comparison\") {\n        newArray[nextAction.first!].isCompared = true;\n        newArray[nextAction.second!].isCompared = true;\n        updateArray(newArray);\n      } else if (nextAction.type === \"swapColors\") {\n        newArray[nextAction.first!].isCompared = false;\n        newArray[nextAction.second!].isCompared = false;\n        newArray[nextAction.first!].isSwapped = true;\n        newArray[nextAction.second!].isSwapped = true;\n      } else if (nextAction.type === \"swap\") {\n        let temp = newArray[nextAction.first!];\n        newArray[nextAction.first!] = newArray[nextAction.second!];\n        newArray[nextAction.second!] = temp;\n      } else if (nextAction.type === \"clean\") {\n        newArray.forEach((b) => {\n          b.isCompared = false;\n          b.isSwapped = false;\n          b.isPivot = false;\n        });\n      } else if (nextAction.type === \"set_pivot\") {\n        newArray[nextAction.pivot!].isPivot = true;\n      }\n      updateArray(newArray);\n    }\n  }, [nextAction, updateArray]);\n  return (\n    <Container>\n      {sortTarget.map((element, i) => (\n        <SortingBar element={element} speed={speed} key={i} index={i} />\n      ))}\n    </Container>\n  );\n};\n\nconst mapStateToProps = (state: IComponentState) => ({\n  sortTarget: state.sortTarget,\n  nextAction: state.nextactions,\n  speed: state.speed,\n});\n\nconst mapDispatchToProps = (dispatch: any) => ({\n  //update array elements\n  updateArray: (sortTarget: Array<ISortTargetPayload>) =>\n    dispatch(updateArray({ sortTarget })),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(SortingBoard);\n"]},"metadata":{},"sourceType":"module"}