{"ast":null,"code":"export const getSortingGenerator = (visualizer, algo) => {\n  // 1. bubble sort\n  if (algo === 1) {\n    return visualizer.BubbleSort();\n  } //2. merge sort\n  //3. quick sort\n  //4.\n  else {\n      return null;\n    }\n};\nexport const getSortTarget = (size, arr) => {\n  let sortObj = [];\n\n  for (let i = 0; i < size; i++) {\n    sortObj.push({\n      value: arr[i],\n      isCompared: false,\n      isSwapped: false,\n      isDone: false\n    });\n  }\n\n  return sortObj;\n}; // export const generateArrayFromOptions = (\n//   length: string,\n//   initial: string\n// ): Array<IBar> => {\n//   const arrLength = parseInt(length);\n//   let result = Array.from({ length: arrLength }, () => ({\n//     value: 0,\n//     isCompared: false,\n//     isSwapped: false,\n//   }));\n//   if (initial === \"Random\") {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[i].value = i + 1;\n//     }\n//     shuffle(result);\n//   } else if (initial === \"Reversed\") {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[arrLength - i - 1].value = i + 1;\n//     }\n//   } else {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[i].value = i + 1;\n//     }\n//     // 20% of elements will be shuffled\n//     const swapFactor = MAX_SWAP_FACTOR;\n//     let maxSwaps = Math.floor(swapFactor * arrLength);\n//     const swapInterval = Math.floor(1 / swapFactor);\n//     let position = 0;\n//     while (maxSwaps && position < arrLength) {\n//       const slotSwap = Math.floor(Math.random() * swapInterval) + position;\n//       [result[slotSwap].value, result[position].value] = [\n//         result[position].value,\n//         result[slotSwap].value,\n//       ];\n//       maxSwaps--;\n//       position += swapInterval;\n//     }\n//   }\n//   return result;\n// };","map":{"version":3,"sources":["/Users/yen/Documents/project/sorting-algo/src/Utils/utils.ts"],"names":["getSortingGenerator","visualizer","algo","BubbleSort","getSortTarget","size","arr","sortObj","i","push","value","isCompared","isSwapped","isDone"],"mappings":"AAGA,OAAO,MAAMA,mBAAmB,GAAG,CACjCC,UADiC,EAEjCC,IAFiC,KAGQ;AACzC;AACA,MAAIA,IAAI,KAAK,CAAb,EAAgB;AACd,WAAOD,UAAU,CAACE,UAAX,EAAP;AACD,GAFD,CAGA;AAEA;AAEA;AAPA,OAQK;AACH,aAAO,IAAP;AACD;AACF,CAhBM;AAkBP,OAAO,MAAMC,aAAa,GAAG,CAC3BC,IAD2B,EAE3BC,GAF2B,KAGG;AAC9B,MAAIC,OAAkC,GAAG,EAAzC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAApB,EAA0BG,CAAC,EAA3B,EAA+B;AAC7BD,IAAAA,OAAO,CAACE,IAAR,CAAa;AACXC,MAAAA,KAAK,EAAEJ,GAAG,CAACE,CAAD,CADC;AAEXG,MAAAA,UAAU,EAAE,KAFD;AAGXC,MAAAA,SAAS,EAAE,KAHA;AAIXC,MAAAA,MAAM,EAAE;AAJG,KAAb;AAMD;;AACD,SAAON,OAAP;AACD,CAdM,C,CAgBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { ISwapAction, ISortTargetPayload } from \"../constants/Itypes\";\nimport sortingVisualizer from \"../Visualizer/SortingVisualizer\";\n\nexport const getSortingGenerator = (\n  visualizer: sortingVisualizer,\n  algo: number\n): IterableIterator<ISwapAction> | null => {\n  // 1. bubble sort\n  if (algo === 1) {\n    return visualizer.BubbleSort();\n  }\n  //2. merge sort\n\n  //3. quick sort\n\n  //4.\n  else {\n    return null;\n  }\n};\n\nexport const getSortTarget = (\n  size: number,\n  arr: Array<number>\n): Array<ISortTargetPayload> => {\n  let sortObj: Array<ISortTargetPayload> = [];\n  for (let i = 0; i < size; i++) {\n    sortObj.push({\n      value: arr[i],\n      isCompared: false,\n      isSwapped: false,\n      isDone: false,\n    });\n  }\n  return sortObj;\n};\n\n// export const generateArrayFromOptions = (\n//   length: string,\n//   initial: string\n// ): Array<IBar> => {\n//   const arrLength = parseInt(length);\n//   let result = Array.from({ length: arrLength }, () => ({\n//     value: 0,\n//     isCompared: false,\n//     isSwapped: false,\n//   }));\n//   if (initial === \"Random\") {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[i].value = i + 1;\n//     }\n//     shuffle(result);\n//   } else if (initial === \"Reversed\") {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[arrLength - i - 1].value = i + 1;\n//     }\n//   } else {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[i].value = i + 1;\n//     }\n//     // 20% of elements will be shuffled\n//     const swapFactor = MAX_SWAP_FACTOR;\n//     let maxSwaps = Math.floor(swapFactor * arrLength);\n//     const swapInterval = Math.floor(1 / swapFactor);\n\n//     let position = 0;\n//     while (maxSwaps && position < arrLength) {\n//       const slotSwap = Math.floor(Math.random() * swapInterval) + position;\n//       [result[slotSwap].value, result[position].value] = [\n//         result[position].value,\n//         result[slotSwap].value,\n//       ];\n//       maxSwaps--;\n//       position += swapInterval;\n//     }\n//   }\n//   return result;\n// };\n"]},"metadata":{},"sourceType":"module"}