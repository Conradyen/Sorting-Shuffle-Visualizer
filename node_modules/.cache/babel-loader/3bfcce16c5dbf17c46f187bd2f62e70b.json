{"ast":null,"code":"export default class sortingVisualizer {\n  constructor(array) {\n    this.arr = void 0;\n    this.len = void 0;\n    this.arr = array;\n    this.len = array.length;\n  }\n\n  *BubbleSort() {\n    // let n = this.arr.length;\n    let temparr = [...this.arr];\n\n    for (let i = 0; i < this.len; i++) {\n      for (let j = 0; j < this.len - i - 1; j++) {\n        yield {\n          type: \"comparison\",\n          first: j,\n          second: j + 1\n        };\n\n        if (temparr[j].value > temparr[j + 1].value) {\n          yield {\n            type: \"swap\",\n            first: j,\n            second: j + 1\n          };\n          var _ref = [temparr[j + 1], temparr[j]];\n          temparr[j] = _ref[0];\n          temparr[j + 1] = _ref[1];\n        }\n      }\n    }\n  }\n\n  *MergeSort() {\n    let temparr = [...this.arr];\n\n    function* _merge(arr, start, mid, end) {\n      let k = start;\n      let i = start;\n      let j = mid + 1;\n\n      while (i <= mid && j <= end) {\n        yield {\n          type: \"comparison\",\n          first: i,\n          second: j\n        };\n\n        if (temparr[i] <= temparr[j]) {\n          // yield { type: \"swap\", first: k, second: i };\n          // [temparr[k], temparr[i]] = [temparr[i], temparr[k]];\n          i++;\n          k++; // j++;\n        } else {\n          yield {\n            type: \"swap\",\n            first: i,\n            second: j\n          };\n          var _ref2 = [temparr[j], temparr[i]];\n          temparr[i] = _ref2[0];\n          temparr[j] = _ref2[1];\n          k++;\n          i++;\n          j++;\n        }\n      } // while (i <= mid) {\n      //   yield { type: \"swap\", first: i, second: k };\n      //   [temparr[k], temparr[i]] = [temparr[i], temparr[k]];\n      //   k++;\n      //   i++;\n      // }\n      // while (j <= end) {\n      //   yield { type: \"swap\", first: j, second: k };\n      //   [temparr[k], temparr[j]] = [temparr[j], temparr[k]];\n      //   k++;\n      //   j++;\n      // }\n\n    }\n\n    function* _mergeSortHelper(arr, start, end) {\n      if (start === end) return;\n      let mid = Math.floor(start + (end - start) / 2);\n      yield* _mergeSortHelper(arr, start, mid);\n      yield* _mergeSortHelper(arr, mid + 1, end);\n      yield* _merge(arr, start, mid, end);\n    }\n\n    yield* _mergeSortHelper(temparr, 0, this.len - 1);\n  }\n\n  *QuickSort() {\n    function* _qsort(temparr, low_idx, high_idx) {\n      if (high_idx > low_idx) {\n        let pivot = temparr[high_idx].value;\n        yield {\n          type: \"set_pivot\",\n          pivot: high_idx\n        };\n        let i = low_idx - 1; // index of smaller element\n\n        for (let j = low_idx; j < high_idx; j++) {\n          yield {\n            type: \"comparison\",\n            first: j,\n            second: low_idx\n          }; // If current element is smaller than the pivot\n\n          if (temparr[j].value < pivot) {\n            i++;\n            yield {\n              type: \"swap\",\n              first: j,\n              second: i\n            };\n            var _ref3 = [temparr[j], temparr[i]];\n            temparr[i] = _ref3[0];\n            temparr[j] = _ref3[1];\n          }\n        } // swap arr[i+1] and arr[high] (or pivot)\n\n\n        yield {\n          type: \"swap\",\n          first: i + 1,\n          second: high_idx\n        };\n        var _ref4 = [temparr[high_idx], temparr[i + 1]];\n        temparr[i + 1] = _ref4[0];\n        temparr[high_idx] = _ref4[1];\n        pivot = i + 1; // yield { type: \"clean_pivot\", pivot: high_idx };\n\n        yield* _qsort(temparr, low_idx, pivot - 1);\n        yield* _qsort(temparr, pivot + 1, high_idx);\n      }\n    }\n\n    let temparr = [...this.arr];\n    yield* _qsort(temparr, 0, this.len - 1);\n  }\n\n  *InsertionSort() {\n    let temparr = [...this.arr];\n\n    for (let i = 1; i < temparr.length; ++i) {\n      let key = temparr[i].value;\n      let j = i - 1;\n      /* Move elements of arr[0..i-1], that are \n               greater than key, to one position ahead \n               of their current position */\n\n      yield {\n        type: \"comparison\",\n        first: j,\n        second: i\n      };\n\n      while (j >= 0 && temparr[j].value > key) {\n        yield {\n          type: \"swap\",\n          first: j,\n          second: j + 1\n        };\n        var _ref5 = [temparr[j], temparr[j + 1]];\n        temparr[j + 1] = _ref5[0];\n        temparr[j] = _ref5[1];\n        j--; // yield compare if next is a comparison\n\n        if (j > 0) {\n          yield {\n            type: \"comparison\",\n            first: j - 1,\n            second: i\n          };\n        }\n      } // yield { type: \"swap\", first: i, second: j };\n      // [temparr[j], temparr[i]] = [temparr[i], temparr[j]];\n      // temparr[j + 1].value = key;\n\n    }\n  }\n\n  *SelectionSort() {\n    let temparr = [...this.arr];\n\n    for (let i = 0; i < this.len - 1; i++) {\n      // Find the minimum element in unsorted array\n      let min_idx = i;\n      let j;\n\n      for (j = i + 1; j < this.len; j++) {\n        yield {\n          type: \"comparison\",\n          first: min_idx,\n          second: j\n        };\n        if (temparr[j] < temparr[min_idx]) min_idx = j;\n      } // Swap the found minimum element with the first\n\n\n      yield {\n        type: \"swap\",\n        first: min_idx,\n        second: j\n      };\n      var _ref6 = [temparr[j], temparr[min_idx]];\n      temparr[min_idx] = _ref6[0];\n      temparr[j] = _ref6[1];\n    }\n  }\n\n  *HeapSort() {\n    let temparr = [...this.arr];\n    let n = this.len;\n\n    function* _heapify(arr, size, node) {\n      let largest = node; // Initialize largest as root\n\n      let l = 2 * node + 1; // left = 2*i + 1\n\n      let r = 2 * node + 2; // right = 2*i + 2\n      // If left child is larger than root\n\n      if (l < size && arr[l] > arr[largest]) {\n        yield {\n          type: \"comparison\",\n          first: l,\n          second: largest\n        };\n        largest = l;\n      } // If right child is larger than largest so far\n\n\n      if (r < size && arr[r] > arr[largest]) {\n        yield {\n          type: \"comparison\",\n          first: r,\n          second: largest\n        };\n        largest = r;\n      } // If largest is not root\n\n\n      if (largest !== node) {\n        var _ref7 = [arr[largest], arr[node]];\n        arr[node] = _ref7[0];\n        arr[largest] = _ref7[1];\n        yield {\n          type: \"swap\",\n          first: node,\n          second: largest\n        }; // Recursively heapify the affected sub-tree\n\n        yield* _heapify(arr, size, largest);\n      }\n    }\n\n    function* _heapSort(arr) {\n      // Build heap (rearrange array)\n      let i;\n\n      for (i = n / 2 - 1; i >= 0; i--) {\n        yield* _heapify(arr, n, i);\n      } // One by one extract an element from heap\n\n\n      for (i = n - 1; i > 0; i--) {\n        yield {\n          type: \"swap\",\n          first: 0,\n          second: i\n        };\n        var _ref8 = [arr[i], arr[0]];\n        arr[0] = _ref8[0];\n        arr[i] = _ref8[1];\n        // call max heapify on the reduced heap\n        yield* _heapify(arr, i, 0);\n      }\n    }\n\n    yield* _heapSort(temparr);\n  }\n\n}","map":{"version":3,"sources":["/Users/yen/Documents/project/sorting-algo/src/Visualizer/SortingVisualizer.ts"],"names":["sortingVisualizer","constructor","array","arr","len","length","BubbleSort","temparr","i","j","type","first","second","value","MergeSort","_merge","start","mid","end","k","_mergeSortHelper","Math","floor","QuickSort","_qsort","low_idx","high_idx","pivot","InsertionSort","key","SelectionSort","min_idx","HeapSort","n","_heapify","size","node","largest","l","r","_heapSort"],"mappings":"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","sourcesContent":["import { ISwapAction, ISortTargetPayload } from \"../constants/Itypes\";\n\nexport default class sortingVisualizer {\n  arr: Array<ISortTargetPayload>;\n  len: number;\n\n  constructor(array: Array<ISortTargetPayload>) {\n    this.arr = array;\n    this.len = array.length;\n  }\n  *BubbleSort(): IterableIterator<ISwapAction> {\n    // let n = this.arr.length;\n    let temparr = [...this.arr];\n    for (let i = 0; i < this.len; i++) {\n      for (let j = 0; j < this.len - i - 1; j++) {\n        yield { type: \"comparison\", first: j, second: j + 1 };\n        if (temparr[j].value > temparr[j + 1].value) {\n          yield { type: \"swap\", first: j, second: j + 1 };\n          [temparr[j], temparr[j + 1]] = [temparr[j + 1], temparr[j]];\n        }\n      }\n    }\n  }\n  *MergeSort(): IterableIterator<ISwapAction> {\n    let temparr = [...this.arr];\n    function* _merge(\n      arr: Array<ISortTargetPayload>,\n      start: number,\n      mid: number,\n      end: number\n    ): IterableIterator<ISwapAction> {\n      let k = start;\n      let i = start;\n      let j = mid + 1;\n      while (i <= mid && j <= end) {\n        yield { type: \"comparison\", first: i, second: j };\n        if (temparr[i] <= temparr[j]) {\n          // yield { type: \"swap\", first: k, second: i };\n          // [temparr[k], temparr[i]] = [temparr[i], temparr[k]];\n          i++;\n          k++;\n          // j++;\n        } else {\n          yield { type: \"swap\", first: i, second: j };\n          [temparr[i], temparr[j]] = [temparr[j], temparr[i]];\n          k++;\n          i++;\n          j++;\n        }\n      }\n      // while (i <= mid) {\n      //   yield { type: \"swap\", first: i, second: k };\n      //   [temparr[k], temparr[i]] = [temparr[i], temparr[k]];\n      //   k++;\n      //   i++;\n      // }\n      // while (j <= end) {\n      //   yield { type: \"swap\", first: j, second: k };\n      //   [temparr[k], temparr[j]] = [temparr[j], temparr[k]];\n      //   k++;\n      //   j++;\n      // }\n    }\n    function* _mergeSortHelper(\n      arr: Array<ISortTargetPayload>,\n      start: number,\n      end: number\n    ): IterableIterator<ISwapAction> {\n      if (start === end) return;\n      let mid = Math.floor(start + (end - start) / 2);\n      yield* _mergeSortHelper(arr, start, mid);\n      yield* _mergeSortHelper(arr, mid + 1, end);\n      yield* _merge(arr, start, mid, end);\n    }\n    yield* _mergeSortHelper(temparr, 0, this.len - 1);\n  }\n\n  *QuickSort(): IterableIterator<ISwapAction> {\n    function* _qsort(\n      temparr: Array<ISortTargetPayload>,\n      low_idx: number,\n      high_idx: number\n    ): IterableIterator<ISwapAction> {\n      if (high_idx > low_idx) {\n        let pivot = temparr[high_idx].value;\n        yield { type: \"set_pivot\", pivot: high_idx };\n        let i = low_idx - 1; // index of smaller element\n        for (let j = low_idx; j < high_idx; j++) {\n          yield { type: \"comparison\", first: j, second: low_idx };\n          // If current element is smaller than the pivot\n          if (temparr[j].value < pivot) {\n            i++;\n            yield { type: \"swap\", first: j, second: i };\n            [temparr[i], temparr[j]] = [temparr[j], temparr[i]];\n          }\n        }\n        // swap arr[i+1] and arr[high] (or pivot)\n        yield { type: \"swap\", first: i + 1, second: high_idx };\n        [temparr[i + 1], temparr[high_idx]] = [\n          temparr[high_idx],\n          temparr[i + 1],\n        ];\n        pivot = i + 1;\n        // yield { type: \"clean_pivot\", pivot: high_idx };\n        yield* _qsort(temparr, low_idx, pivot - 1);\n        yield* _qsort(temparr, pivot + 1, high_idx);\n      }\n    }\n    let temparr = [...this.arr];\n    yield* _qsort(temparr, 0, this.len - 1);\n  }\n  *InsertionSort(): IterableIterator<ISwapAction> {\n    let temparr = [...this.arr];\n    for (let i = 1; i < temparr.length; ++i) {\n      let key = temparr[i].value;\n      let j = i - 1;\n      /* Move elements of arr[0..i-1], that are \n               greater than key, to one position ahead \n               of their current position */\n      yield { type: \"comparison\", first: j, second: i };\n      while (j >= 0 && temparr[j].value > key) {\n        yield { type: \"swap\", first: j, second: j + 1 };\n        [temparr[j + 1], temparr[j]] = [temparr[j], temparr[j + 1]];\n        j--;\n        // yield compare if next is a comparison\n        if (j > 0) {\n          yield { type: \"comparison\", first: j - 1, second: i };\n        }\n      }\n      // yield { type: \"swap\", first: i, second: j };\n      // [temparr[j], temparr[i]] = [temparr[i], temparr[j]];\n      // temparr[j + 1].value = key;\n    }\n  }\n  *SelectionSort(): IterableIterator<ISwapAction> {\n    let temparr = [...this.arr];\n    for (let i = 0; i < this.len - 1; i++) {\n      // Find the minimum element in unsorted array\n      let min_idx = i;\n      let j;\n      for (j = i + 1; j < this.len; j++) {\n        yield { type: \"comparison\", first: min_idx, second: j };\n        if (temparr[j] < temparr[min_idx]) min_idx = j;\n      }\n      // Swap the found minimum element with the first\n      yield { type: \"swap\", first: min_idx, second: j };\n      [temparr[min_idx], temparr[j]] = [temparr[j], temparr[min_idx]];\n    }\n  }\n  *HeapSort(): IterableIterator<ISwapAction> {\n    let temparr = [...this.arr];\n    let n = this.len;\n    function* _heapify(\n      arr: Array<ISortTargetPayload>,\n      size: number,\n      node: number\n    ): IterableIterator<ISwapAction> {\n      let largest = node; // Initialize largest as root\n      let l = 2 * node + 1; // left = 2*i + 1\n      let r = 2 * node + 2; // right = 2*i + 2\n      // If left child is larger than root\n      if (l < size && arr[l] > arr[largest]) {\n        yield { type: \"comparison\", first: l, second: largest };\n        largest = l;\n      }\n      // If right child is larger than largest so far\n      if (r < size && arr[r] > arr[largest]) {\n        yield { type: \"comparison\", first: r, second: largest };\n        largest = r;\n      }\n      // If largest is not root\n      if (largest !== node) {\n        [arr[node], arr[largest]] = [arr[largest], arr[node]];\n        yield { type: \"swap\", first: node, second: largest };\n        // Recursively heapify the affected sub-tree\n        yield* _heapify(arr, size, largest);\n      }\n    }\n    function* _heapSort(\n      arr: Array<ISortTargetPayload>\n    ): IterableIterator<ISwapAction> {\n      // Build heap (rearrange array)\n      let i: number;\n      for (i = n / 2 - 1; i >= 0; i--) {\n        yield* _heapify(arr, n, i);\n      }\n      // One by one extract an element from heap\n      for (i = n - 1; i > 0; i--) {\n        yield { type: \"swap\", first: 0, second: i };\n        [arr[0], arr[i]] = [arr[i], arr[0]];\n        // call max heapify on the reduced heap\n        yield* _heapify(arr, i, 0);\n      }\n    }\n    yield* _heapSort(temparr);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}