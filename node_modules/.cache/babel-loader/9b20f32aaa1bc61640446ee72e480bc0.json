{"ast":null,"code":"export default class sortingVisualizer {\n  constructor(array) {\n    this.arr = void 0;\n    this.len = void 0;\n    this.arr = array;\n    this.len = array.length;\n  }\n\n  *BubbleSort() {\n    // let n = this.arr.length;\n    let temparr = [...this.arr];\n\n    for (let i = 0; i < this.len; i++) {\n      for (let j = 0; j < this.len - i - 1; j++) {\n        yield {\n          type: \"comparison\",\n          first: j,\n          second: j + 1\n        };\n\n        if (temparr[j].value > temparr[j + 1].value) {\n          yield {\n            type: \"swap\",\n            first: j,\n            second: j + 1\n          };\n          var _ref = [temparr[j + 1], temparr[j]];\n          temparr[j] = _ref[0];\n          temparr[j + 1] = _ref[1];\n        }\n      }\n    }\n  }\n\n  *MergeSort() {\n    let temparr = [...this.arr];\n\n    function* _merge(arr, start, mid, end) {\n      let start2 = mid + 1; // If the direct merge is already sorted\n\n      if (temparr[mid].value <= temparr[start2].value) {\n        return;\n      } // Two pointers to maintain start\n      // of both arrays to merge\n\n\n      while (start <= mid && start2 <= end) {\n        yield {\n          type: \"comparison\",\n          first: start,\n          second: start2\n        }; // If element 1 is in right place\n\n        if (temparr[start].value <= temparr[start2].value) {\n          start++;\n        } else {\n          let value = temparr[start2].value;\n          let index = start2; // Shift all the elements between element 1\n          // element 2, right by 1.\n\n          while (index !== start) {\n            yield {\n              type: \"swap\",\n              first: index,\n              second: index - 1\n            };\n            var _ref2 = [temparr[index - 1], temparr[index]];\n            temparr[index] = _ref2[0];\n            temparr[index - 1] = _ref2[1];\n            index--;\n          }\n\n          yield {\n            type: \"swap-\",\n            first: start,\n            second: start2\n          };\n          var _ref3 = [temparr[start2], temparr[start]];\n          temparr[start] = _ref3[0];\n          temparr[start2] = _ref3[1];\n          // temparr[start].value = value;\n          // Update all the pointers\n          start++;\n          mid++;\n          start2++;\n        }\n      }\n    }\n\n    function* _mergeSortHelper(arr, start, end) {\n      if (start < end) {\n        let mid = Math.floor((start + end) / 2);\n        yield* _mergeSortHelper(arr, start, mid);\n        yield* _mergeSortHelper(arr, mid + 1, end);\n        yield* _merge(arr, start, mid, end);\n      }\n    }\n\n    yield* _mergeSortHelper(temparr, 0, this.len - 1);\n  }\n\n  *QuickSort() {\n    function* _qsort(temparr, low_idx, high_idx) {\n      if (high_idx > low_idx) {\n        let pivot = temparr[high_idx].value;\n        yield {\n          type: \"set_pivot\",\n          pivot: high_idx\n        };\n        let i = low_idx - 1; // index of smaller element\n\n        for (let j = low_idx; j < high_idx; j++) {\n          yield {\n            type: \"comparison\",\n            first: j,\n            second: low_idx\n          }; // If current element is smaller than the pivot\n\n          if (temparr[j].value < pivot) {\n            i++;\n            yield {\n              type: \"swap\",\n              first: j,\n              second: i\n            };\n            var _ref4 = [temparr[j], temparr[i]];\n            temparr[i] = _ref4[0];\n            temparr[j] = _ref4[1];\n          }\n        } // swap arr[i+1] and arr[high] (or pivot)\n\n\n        yield {\n          type: \"swap\",\n          first: i + 1,\n          second: high_idx\n        };\n        var _ref5 = [temparr[high_idx], temparr[i + 1]];\n        temparr[i + 1] = _ref5[0];\n        temparr[high_idx] = _ref5[1];\n        pivot = i + 1; // yield { type: \"clean_pivot\", pivot: high_idx };\n\n        yield* _qsort(temparr, low_idx, pivot - 1);\n        yield* _qsort(temparr, pivot + 1, high_idx);\n      }\n    }\n\n    let temparr = [...this.arr];\n    yield* _qsort(temparr, 0, this.len - 1);\n  }\n\n  *InsertionSort() {\n    let temparr = [...this.arr];\n\n    for (let i = 1; i < temparr.length; ++i) {\n      let key = temparr[i].value;\n      let j = i - 1;\n      /* Move elements of arr[0..i-1], that are \n               greater than key, to one position ahead \n               of their current position */\n\n      yield {\n        type: \"comparison\",\n        first: j,\n        second: i\n      };\n\n      while (j >= 0 && temparr[j].value > key) {\n        yield {\n          type: \"swap\",\n          first: j,\n          second: j + 1\n        };\n        var _ref6 = [temparr[j], temparr[j + 1]];\n        temparr[j + 1] = _ref6[0];\n        temparr[j] = _ref6[1];\n        j--; // yield compare if next is a comparison\n\n        if (j > 0) {\n          yield {\n            type: \"comparison\",\n            first: j - 1,\n            second: i\n          };\n        }\n      } // yield { type: \"swap\", first: i, second: j };\n      // [temparr[j], temparr[i]] = [temparr[i], temparr[j]];\n      // temparr[j + 1].value = key;\n\n    }\n  }\n\n  *SelectionSort() {\n    let temparr = [...this.arr];\n\n    for (let i = 0; i < this.len - 1; i++) {\n      // Find the minimum element in unsorted array\n      let min_idx = i;\n      let j;\n\n      for (j = i + 1; j < this.len; j++) {\n        yield {\n          type: \"comparison\",\n          first: min_idx,\n          second: j\n        };\n        if (temparr[j].value < temparr[min_idx].value) min_idx = j;\n      } // Swap the found minimum element with the first\n\n\n      yield {\n        type: \"swap\",\n        first: min_idx,\n        second: i\n      };\n      var _ref7 = [temparr[i], temparr[min_idx]];\n      temparr[min_idx] = _ref7[0];\n      temparr[i] = _ref7[1];\n    }\n  }\n\n  *HeapSort() {\n    let temparr = [...this.arr];\n    let n = this.len;\n\n    function* _heapify(arr, size, node) {\n      let largest = node; // Initialize largest as root\n\n      let l = 2 * node + 1; // left = 2*i + 1\n\n      let r = 2 * node + 2; // right = 2*i + 2\n      // If left child is larger than root\n\n      if (l < size && arr[l].value > arr[largest].value) {\n        yield {\n          type: \"comparison\",\n          first: l,\n          second: largest\n        };\n        largest = l;\n      } // If right child is larger than largest so far\n\n\n      if (r < size && arr[r].value > arr[largest].value) {\n        yield {\n          type: \"comparison\",\n          first: r,\n          second: largest\n        };\n        largest = r;\n      } // If largest is not root\n\n\n      if (largest !== node) {\n        var _ref8 = [arr[largest], arr[node]];\n        arr[node] = _ref8[0];\n        arr[largest] = _ref8[1];\n        yield {\n          type: \"swap\",\n          first: node,\n          second: largest\n        }; // Recursively heapify the affected sub-tree\n\n        yield* _heapify(arr, size, largest);\n      }\n    }\n\n    function* _heapSort(arr) {\n      // Build heap (rearrange array)\n      let i;\n\n      for (i = n / 2 - 1; i >= 0; i--) {\n        yield* _heapify(arr, n, i);\n      } // One by one extract an element from heap\n\n\n      for (i = n - 1; i > 0; i--) {\n        yield {\n          type: \"swap\",\n          first: 0,\n          second: i\n        };\n        var _ref9 = [arr[i], arr[0]];\n        arr[0] = _ref9[0];\n        arr[i] = _ref9[1];\n        // call max heapify on the reduced heap\n        yield* _heapify(arr, i, 0);\n      }\n    }\n\n    yield* _heapSort(temparr);\n  }\n\n}","map":{"version":3,"sources":["/Users/yen/Documents/project/sorting-algo/src/Visualizer/SortingVisualizer.ts"],"names":["sortingVisualizer","constructor","array","arr","len","length","BubbleSort","temparr","i","j","type","first","second","value","MergeSort","_merge","start","mid","end","start2","index","_mergeSortHelper","Math","floor","QuickSort","_qsort","low_idx","high_idx","pivot","InsertionSort","key","SelectionSort","min_idx","HeapSort","n","_heapify","size","node","largest","l","r","_heapSort"],"mappings":"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","sourcesContent":["import { ISwapAction, ISortTargetPayload } from \"../constants/Itypes\";\n\nexport default class sortingVisualizer {\n  arr: Array<ISortTargetPayload>;\n  len: number;\n\n  constructor(array: Array<ISortTargetPayload>) {\n    this.arr = array;\n    this.len = array.length;\n  }\n  *BubbleSort(): IterableIterator<ISwapAction> {\n    // let n = this.arr.length;\n    let temparr = [...this.arr];\n    for (let i = 0; i < this.len; i++) {\n      for (let j = 0; j < this.len - i - 1; j++) {\n        yield { type: \"comparison\", first: j, second: j + 1 };\n        if (temparr[j].value > temparr[j + 1].value) {\n          yield { type: \"swap\", first: j, second: j + 1 };\n          [temparr[j], temparr[j + 1]] = [temparr[j + 1], temparr[j]];\n        }\n      }\n    }\n  }\n  *MergeSort(): IterableIterator<ISwapAction> {\n    let temparr = [...this.arr];\n    function* _merge(\n      arr: Array<ISortTargetPayload>,\n      start: number,\n      mid: number,\n      end: number\n    ): IterableIterator<ISwapAction> {\n      let start2 = mid + 1;\n      // If the direct merge is already sorted\n      if (temparr[mid].value <= temparr[start2].value) {\n        return;\n      }\n      // Two pointers to maintain start\n      // of both arrays to merge\n      while (start <= mid && start2 <= end) {\n        yield { type: \"comparison\", first: start, second: start2 };\n        // If element 1 is in right place\n        if (temparr[start].value <= temparr[start2].value) {\n          start++;\n        } else {\n          let value = temparr[start2].value;\n          let index = start2;\n          // Shift all the elements between element 1\n          // element 2, right by 1.\n          while (index !== start) {\n            yield { type: \"swap\", first: index, second: index - 1 };\n            [temparr[index], temparr[index - 1]] = [\n              temparr[index - 1],\n              temparr[index],\n            ];\n            index--;\n          }\n          yield { type: \"swap-\", first: start, second: start2 };\n          [temparr[start], temparr[start2]] = [temparr[start2], temparr[start]];\n          // temparr[start].value = value;\n\n          // Update all the pointers\n          start++;\n          mid++;\n          start2++;\n        }\n      }\n    }\n    function* _mergeSortHelper(\n      arr: Array<ISortTargetPayload>,\n      start: number,\n      end: number\n    ): IterableIterator<ISwapAction> {\n      if (start < end) {\n        let mid = Math.floor((start + end) / 2);\n        yield* _mergeSortHelper(arr, start, mid);\n        yield* _mergeSortHelper(arr, mid + 1, end);\n        yield* _merge(arr, start, mid, end);\n      }\n    }\n    yield* _mergeSortHelper(temparr, 0, this.len - 1);\n  }\n\n  *QuickSort(): IterableIterator<ISwapAction> {\n    function* _qsort(\n      temparr: Array<ISortTargetPayload>,\n      low_idx: number,\n      high_idx: number\n    ): IterableIterator<ISwapAction> {\n      if (high_idx > low_idx) {\n        let pivot = temparr[high_idx].value;\n        yield { type: \"set_pivot\", pivot: high_idx };\n        let i = low_idx - 1; // index of smaller element\n        for (let j = low_idx; j < high_idx; j++) {\n          yield { type: \"comparison\", first: j, second: low_idx };\n          // If current element is smaller than the pivot\n          if (temparr[j].value < pivot) {\n            i++;\n            yield { type: \"swap\", first: j, second: i };\n            [temparr[i], temparr[j]] = [temparr[j], temparr[i]];\n          }\n        }\n        // swap arr[i+1] and arr[high] (or pivot)\n        yield { type: \"swap\", first: i + 1, second: high_idx };\n        [temparr[i + 1], temparr[high_idx]] = [\n          temparr[high_idx],\n          temparr[i + 1],\n        ];\n        pivot = i + 1;\n        // yield { type: \"clean_pivot\", pivot: high_idx };\n        yield* _qsort(temparr, low_idx, pivot - 1);\n        yield* _qsort(temparr, pivot + 1, high_idx);\n      }\n    }\n    let temparr = [...this.arr];\n    yield* _qsort(temparr, 0, this.len - 1);\n  }\n  *InsertionSort(): IterableIterator<ISwapAction> {\n    let temparr = [...this.arr];\n    for (let i = 1; i < temparr.length; ++i) {\n      let key = temparr[i].value;\n      let j = i - 1;\n      /* Move elements of arr[0..i-1], that are \n               greater than key, to one position ahead \n               of their current position */\n      yield { type: \"comparison\", first: j, second: i };\n      while (j >= 0 && temparr[j].value > key) {\n        yield { type: \"swap\", first: j, second: j + 1 };\n        [temparr[j + 1], temparr[j]] = [temparr[j], temparr[j + 1]];\n        j--;\n        // yield compare if next is a comparison\n        if (j > 0) {\n          yield { type: \"comparison\", first: j - 1, second: i };\n        }\n      }\n      // yield { type: \"swap\", first: i, second: j };\n      // [temparr[j], temparr[i]] = [temparr[i], temparr[j]];\n      // temparr[j + 1].value = key;\n    }\n  }\n  *SelectionSort(): IterableIterator<ISwapAction> {\n    let temparr = [...this.arr];\n    for (let i = 0; i < this.len - 1; i++) {\n      // Find the minimum element in unsorted array\n      let min_idx = i;\n      let j;\n      for (j = i + 1; j < this.len; j++) {\n        yield { type: \"comparison\", first: min_idx, second: j };\n        if (temparr[j].value < temparr[min_idx].value) min_idx = j;\n      }\n      // Swap the found minimum element with the first\n      yield { type: \"swap\", first: min_idx, second: i };\n      [temparr[min_idx], temparr[i]] = [temparr[i], temparr[min_idx]];\n    }\n  }\n  *HeapSort(): IterableIterator<ISwapAction> {\n    let temparr = [...this.arr];\n    let n = this.len;\n    function* _heapify(\n      arr: Array<ISortTargetPayload>,\n      size: number,\n      node: number\n    ): IterableIterator<ISwapAction> {\n      let largest = node; // Initialize largest as root\n      let l = 2 * node + 1; // left = 2*i + 1\n      let r = 2 * node + 2; // right = 2*i + 2\n      // If left child is larger than root\n      if (l < size && arr[l].value > arr[largest].value) {\n        yield { type: \"comparison\", first: l, second: largest };\n        largest = l;\n      }\n      // If right child is larger than largest so far\n      if (r < size && arr[r].value > arr[largest].value) {\n        yield { type: \"comparison\", first: r, second: largest };\n        largest = r;\n      }\n      // If largest is not root\n      if (largest !== node) {\n        [arr[node], arr[largest]] = [arr[largest], arr[node]];\n        yield { type: \"swap\", first: node, second: largest };\n        // Recursively heapify the affected sub-tree\n        yield* _heapify(arr, size, largest);\n      }\n    }\n    function* _heapSort(\n      arr: Array<ISortTargetPayload>\n    ): IterableIterator<ISwapAction> {\n      // Build heap (rearrange array)\n      let i: number;\n      for (i = n / 2 - 1; i >= 0; i--) {\n        yield* _heapify(arr, n, i);\n      }\n      // One by one extract an element from heap\n      for (i = n - 1; i > 0; i--) {\n        yield { type: \"swap\", first: 0, second: i };\n        [arr[0], arr[i]] = [arr[i], arr[0]];\n        // call max heapify on the reduced heap\n        yield* _heapify(arr, i, 0);\n      }\n    }\n    yield* _heapSort(temparr);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}