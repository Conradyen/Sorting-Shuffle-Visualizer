{"ast":null,"code":"export const getSortingGenerator = (visualizer, algo) => {\n  // 1. bubble sort\n  if (algo === 1) {\n    return visualizer.BubbleSort();\n  } else if (algo === 2) {\n    //2. merge sort\n    return visualizer.MergeSort();\n  } else if (algo === 3) {\n    //3. quick sort\n    return visualizer.QuickSort();\n  } else if (algo === 4) {\n    //4. insertion sort\n    return visualizer.InsertionSort();\n  } else if (algo === 5) {\n    return visualizer.SelectionSort();\n  } else if (algo === 6) {\n    return visualizer.HeapSort();\n  } else {\n    //return null if error\n    return null;\n  }\n};\nexport const getSortTarget = (size, arr) => {\n  let sortObj = [];\n\n  for (let i = 0; i < size; i++) {\n    sortObj.push({\n      value: arr[i],\n      isCompared: false,\n      isSwapped: false,\n      isDone: false,\n      isPivot: false\n    });\n  }\n\n  return sortObj;\n};\nexport const getShuggleGenerator = (visualizer, algo) => {\n  if (algo === 1) {\n    return visualizer.FYShuffle();\n  }\n}; // export const generateArrayFromOptions = (\n//   length: string,\n//   initial: string\n// ): Array<IBar> => {\n//   const arrLength = parseInt(length);\n//   let result = Array.from({ length: arrLength }, () => ({\n//     value: 0,\n//     isCompared: false,\n//     isSwapped: false,\n//   }));\n//   if (initial === \"Random\") {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[i].value = i + 1;\n//     }\n//     shuffle(result);\n//   } else if (initial === \"Reversed\") {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[arrLength - i - 1].value = i + 1;\n//     }\n//   } else {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[i].value = i + 1;\n//     }\n//     // 20% of elements will be shuffled\n//     const swapFactor = MAX_SWAP_FACTOR;\n//     let maxSwaps = Math.floor(swapFactor * arrLength);\n//     const swapInterval = Math.floor(1 / swapFactor);\n//     let position = 0;\n//     while (maxSwaps && position < arrLength) {\n//       const slotSwap = Math.floor(Math.random() * swapInterval) + position;\n//       [result[slotSwap].value, result[position].value] = [\n//         result[position].value,\n//         result[slotSwap].value,\n//       ];\n//       maxSwaps--;\n//       position += swapInterval;\n//     }\n//   }\n//   return result;\n// };","map":{"version":3,"sources":["/Users/yen/Documents/project/sorting-algo/src/Utils/utils.ts"],"names":["getSortingGenerator","visualizer","algo","BubbleSort","MergeSort","QuickSort","InsertionSort","SelectionSort","HeapSort","getSortTarget","size","arr","sortObj","i","push","value","isCompared","isSwapped","isDone","isPivot","getShuggleGenerator","FYShuffle"],"mappings":"AAGA,OAAO,MAAMA,mBAAmB,GAAG,CACjCC,UADiC,EAEjCC,IAFiC,KAGQ;AACzC;AACA,MAAIA,IAAI,KAAK,CAAb,EAAgB;AACd,WAAOD,UAAU,CAACE,UAAX,EAAP;AACD,GAFD,MAEO,IAAID,IAAI,KAAK,CAAb,EAAgB;AACrB;AACA,WAAOD,UAAU,CAACG,SAAX,EAAP;AACD,GAHM,MAGA,IAAIF,IAAI,KAAK,CAAb,EAAgB;AACrB;AACA,WAAOD,UAAU,CAACI,SAAX,EAAP;AACD,GAHM,MAGA,IAAIH,IAAI,KAAK,CAAb,EAAgB;AACrB;AACA,WAAOD,UAAU,CAACK,aAAX,EAAP;AACD,GAHM,MAGA,IAAIJ,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAOD,UAAU,CAACM,aAAX,EAAP;AACD,GAFM,MAEA,IAAIL,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAOD,UAAU,CAACO,QAAX,EAAP;AACD,GAFM,MAEA;AACL;AACA,WAAO,IAAP;AACD;AACF,CAxBM;AA0BP,OAAO,MAAMC,aAAa,GAAG,CAC3BC,IAD2B,EAE3BC,GAF2B,KAGG;AAC9B,MAAIC,OAAkC,GAAG,EAAzC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAApB,EAA0BG,CAAC,EAA3B,EAA+B;AAC7BD,IAAAA,OAAO,CAACE,IAAR,CAAa;AACXC,MAAAA,KAAK,EAAEJ,GAAG,CAACE,CAAD,CADC;AAEXG,MAAAA,UAAU,EAAE,KAFD;AAGXC,MAAAA,SAAS,EAAE,KAHA;AAIXC,MAAAA,MAAM,EAAE,KAJG;AAKXC,MAAAA,OAAO,EAAE;AALE,KAAb;AAOD;;AACD,SAAOP,OAAP;AACD,CAfM;AAiBP,OAAO,MAAMQ,mBAAmB,GAAG,CACjCnB,UADiC,EAEjCC,IAFiC,KAGQ;AACzC,MAAIA,IAAI,KAAK,CAAb,EAAgB;AACd,WAAOD,UAAU,CAACoB,SAAX,EAAP;AACD;AACF,CAPM,C,CASP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { ISwapAction, ISortTargetPayload } from \"../constants/Itypes\";\nimport sortingVisualizer from \"../Visualizer/SortingVisualizer\";\nimport ShuffleVisualizer from \"../Visualizer/ShuffleVisualizer\";\nexport const getSortingGenerator = (\n  visualizer: sortingVisualizer,\n  algo: number\n): IterableIterator<ISwapAction> | null => {\n  // 1. bubble sort\n  if (algo === 1) {\n    return visualizer.BubbleSort();\n  } else if (algo === 2) {\n    //2. merge sort\n    return visualizer.MergeSort();\n  } else if (algo === 3) {\n    //3. quick sort\n    return visualizer.QuickSort();\n  } else if (algo === 4) {\n    //4. insertion sort\n    return visualizer.InsertionSort();\n  } else if (algo === 5) {\n    return visualizer.SelectionSort();\n  } else if (algo === 6) {\n    return visualizer.HeapSort();\n  } else {\n    //return null if error\n    return null;\n  }\n};\n\nexport const getSortTarget = (\n  size: number,\n  arr: Array<number>\n): Array<ISortTargetPayload> => {\n  let sortObj: Array<ISortTargetPayload> = [];\n  for (let i = 0; i < size; i++) {\n    sortObj.push({\n      value: arr[i],\n      isCompared: false,\n      isSwapped: false,\n      isDone: false,\n      isPivot: false,\n    });\n  }\n  return sortObj;\n};\n\nexport const getShuggleGenerator = (\n  visualizer: ShuffleVisualizer,\n  algo: number\n): IterableIterator<ISwapAction> | null => {\n  if (algo === 1) {\n    return visualizer.FYShuffle();\n  }\n};\n\n// export const generateArrayFromOptions = (\n//   length: string,\n//   initial: string\n// ): Array<IBar> => {\n//   const arrLength = parseInt(length);\n//   let result = Array.from({ length: arrLength }, () => ({\n//     value: 0,\n//     isCompared: false,\n//     isSwapped: false,\n//   }));\n//   if (initial === \"Random\") {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[i].value = i + 1;\n//     }\n//     shuffle(result);\n//   } else if (initial === \"Reversed\") {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[arrLength - i - 1].value = i + 1;\n//     }\n//   } else {\n//     for (let i = 0; i < arrLength; i++) {\n//       result[i].value = i + 1;\n//     }\n//     // 20% of elements will be shuffled\n//     const swapFactor = MAX_SWAP_FACTOR;\n//     let maxSwaps = Math.floor(swapFactor * arrLength);\n//     const swapInterval = Math.floor(1 / swapFactor);\n\n//     let position = 0;\n//     while (maxSwaps && position < arrLength) {\n//       const slotSwap = Math.floor(Math.random() * swapInterval) + position;\n//       [result[slotSwap].value, result[position].value] = [\n//         result[position].value,\n//         result[slotSwap].value,\n//       ];\n//       maxSwaps--;\n//       position += swapInterval;\n//     }\n//   }\n//   return result;\n// };\n"]},"metadata":{},"sourceType":"module"}